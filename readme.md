# Документация проекта

## Инструкция по запуску приложения

Чтобы запустить приложение, необходимо выполнить следующие шаги:

1. Установите Docker и Docker Compose на вашем компьютере.
2. Скачайте или клонируйте репозиторий с проектом.
3. Откройте терминал в корневой директории проекта.
4. Выполните команду `docker-compose up -d` для сборки и запуска контейнеров.

В корневой директории проекта находится файл `docker-compose.yml`, который описывает конфигурацию приложения. Он включает в себя:

- Контейнер с базой данных PostgreSQL. 
- Контейнер с приложением на языке Kotlin.
- Контейнер с Redis для работы машины состояний.

Описание технологий:
- PostgreSQL - это мощная объектно-реляционная система управления базами данных (ОРСУБД), используемая во многих проектах по всему миру. Выбор PostgreSQL в качестве базы данных для нашего проекта обоснован несколькими причинами:

  1. **Надежность и безопасность**: PostgreSQL известна своей надежностью и безопасностью. Эта система предоставляет множество функций для обеспечения целостности данных и защиты от несанкционированного доступа.
  2. **Масштабируемость**: PostgreSQL поддерживает как вертикальное, так и горизонтальное масштабирование, что позволяет нашему приложению эффективно работать с большими объемами данных и обрабатывать растущее количество запросов.
  3. **Соответствие стандартам**: PostgreSQL соответствует многим стандартам SQL и поддерживает широкий спектр современных функций, таких как JSON, XML, полнотекстовый поиск и пространственные данные.
  4. **Поддержка сообщества**: PostgreSQL имеет большое и активное сообщество пользователей и разработчиков, которое предоставляет обширную документацию, поддержку и множество дополнительных расширений.
  5. **Кросс-платформенность**: PostgreSQL доступна для различных операционных систем, включая Linux, Windows и macOS, что обеспечивает гибкость при развертывании и настройке нашего приложения.

    Используя PostgreSQL в качестве базы данных, мы можем быть уверены в надежности, производительности и масштабируемости нашего приложения, а также в безопасности и целостности хранимых данных.

- Redis - это высокопроизводительное хранилище данных в оперативной памяти с открытым исходным кодом, которое используется в качестве кеша, брокера сообщений и базы данных. Выбор Redis для нашего проекта обоснован несколькими причинами:

  1. **Скорость и производительность**: Redis обеспечивает очень высокую скорость чтения и записи данных, так как они хранятся в оперативной памяти. Это делает Redis идеальным выбором для кеширования и других задач, требующих высокой производительности.
  2. **Гибкость данных**: Redis поддерживает различные типы данных, такие как строки, хэши, списки, множества, отсортированные множества и другие. Это позволяет эффективно хранить и обрабатывать данные в соответствии с требованиями нашего приложения.
  3. **Надежность и отказоустойчивость**: Redis предоставляет различные механизмы репликации и сохранения данных на диск, что обеспечивает надежность и отказоустойчивость хранилища.
  4. **Масштабируемость**: Redis поддерживает масштабирование как вертикально (увеличение объема оперативной памяти), так и горизонтально (распределение данных между несколькими узлами). Это позволяет нашему приложению эффективно работать с большими объемами данных и обрабатывать растущее количество запросов.
  5. **Поддержка сообщества**: Redis имеет большое и активное сообщество пользователей и разработчиков, которое предоставляет обширную документацию, поддержку и множество дополнительных расширений.

    Используя Redis в качестве хранилища данных, мы можем обеспечить высокую производительность и гибкость нашего приложения, а также надежность и отказоустойчивость хранимых данных.


## Демонстрация работы приложения

Приложение представляет собой бота, который помогает пользователям планировать путешествия. Он может находить билеты на поезд, самолёт, предоставлять информацию о погоде в выбранном городе и рекомендовать отели для проживания, достопримечательности, рестораны.

Основные сценарии работы бота:

1. Проектирование путешествия. Пошаговое добавление городов, цели в городах
2. Информация о городе. Как добраться? Какая будет погода? Маршрут. Где поесть? 
3. Рекомендации отелей. Бот предлагает отели и показывает цены в выбранных вами городах.
4. Рекомандация билетов. Бот предлагает возможные Авиа и ЖД билеты, чтобы вы могли добраться до нужного города
5. Чеки. Каждая цель в путешествии имеет свою цену. Также к городу можно добавить "чек дополнительных покупок", например, покупка зубной щётки
6. Распределение чека. В меню путешествия вы можете посмотреть его общую стоимость и сумму, которую каждый отдельный пользователь потратил.
7. Приглашения в путешествия. Вы можете пригласить друга в путешествие, чтобы он имел доступ к просмотру и редактированию вашего приключения.
8. Заметки. Вы можете создавать публичные(доступны всем участникам путешествия) и приватные(доступны только вам) заметки. Заметка может хранить в себе как файл, так и картинку или текст. Каждая заметка имеет имя.

## Описание зависимостей

Этот проект имеет множество зависимостей. Подробнее о них вы можете найти в [докуменет зависимостей](dependencies.md).


## Описание внешних интеграций

### API Яндекс.Расписания

Для поиска билетов на поезд приложение использует API Яндекс.Расписания. Этот сервис предоставляет информацию о расписании поездов, а также позволяет забронировать билеты. Сервис был выбран из-за его высокой точности и надежности.

### API Яндекс.Погоды

Для получения прогноза погоды используется API Яндекс.Погоды. Этот сервис предоставляет информацию о погоде в различных городах мира, включая температуру, влажность, давление и скорость ветра. Сервис был выбран из-за его простоты и широкого охвата городов.

### API Яндекс.Карт

Для получения вокзалов API Яндекс.Карт. Этот сервис предоставляет информацию о расположении вокзалов в различных городах мира, а также geocoder. Сервис был выбран из-за его простоты и надёжности .


### API HotelLook

Для рекомендации отелей используется API HotelLook от Travelpayouts. Этот сервис предоставляет информацию о доступных отелях, их стоимости, рейтинге и отзывах. Сервис был выбран из-за его популярности и широкого выбора отелей.

### API Aviasales

Для поиска авиабилетов используется API Aviasales от Travelpayouts. Этот сервис предоставляет информацию о расписании самолётов, а также позволяет забронировать билеты. Сервис был выбран из-за его высокой точности и надежности, популярности.


### API Sightsafari

Для поиска достопримечательностей используется API Sightsafari с базой OpenStreetMaps. Этот сервис предоставляет список достопримечательностей, а также geocoder для поиска координат мест по названию. Сервис был выбран из-за его высокой точности и доступности.


### API Geoapify

Для генерации маршрутов, статических карт используется API Geoapify с базой OpenStreetMaps. Этот сервис предоставляет geocoder, сервис прокладывания кратчайших маршрутов, рендер статических карт. Сервис был выбран из-за его высокой точности и доступности.


## Схема базы данных

Данный раздел описывает обновленную схему базы данных, используемую в проекте. Проект использует PostgreSQL в качестве системы управления базами данных.

## Таблица пользователей

Таблица `users` хранит информацию о зарегистрированных пользователях.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор записи пользователя. |
| name | varchar | Имя пользователя (до 50 символов). |
| tg\_login | varchar | Логин пользователя в Telegram (до 50 символов). |
| tg\_id | bigint | Идентификатор пользователя в Telegram. |

## Расширенная таблица пользователей

Таблица `extended_user` хранит дополнительную информацию о пользователях.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| tg\_id | bigint | Идентификатор пользователя в Telegram. |
| user\_old | integer | Старый идентификатор пользователя. |
| country\_city | varchar | Город и страна пользователя (до 100 символов). |
| bio | varchar | Биография пользователя (до 300 символов). |

## Таблица приключений

Таблица `adventures` хранит информацию о приключениях.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор приключения. |
| created\_at | bigint | Время создания приключения. |
| name | varchar | Название приключения (до 100 символов). |
| description | varchar | Описание приключения (до 400 символов). |
| created\_by | bigint | Идентификатор пользователя, создавшего приключение. |

## Таблица приглашений на приключения

Таблица `adventure_invites` хранит информацию о приглашениях на приключения.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| adventure\_id | integer | Идентификатор приключения. |
| invited\_user | bigint | Идентификатор приглашенного пользователя. |

## Таблица городов приключений

Таблица `adventure_cities` хранит информацию о городах, связанных с приключениями.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор записи города приключения. |
| name | varchar | Название города (до 100 символов). |
| start\_time | bigint | Время начала приключения в городе. |
| end\_time | bigint | Время окончания приключения в городе. |
| adventure\_id | integer | Идентификатор приключения. |

## Таблица целей (targets)

Таблица `target` хранит информацию о целях, связанных с приключениями.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор цели. |
| name | varchar | Название цели (до 100 символов). |
| city\_id | integer | Идентификатор города, в котором находится цель. |
| created\_at | bigint | Время создания цели. |
| date | bigint | Дата цели. |
| time | varchar | Время цели (до 20 символов). |
| receipt | integer | Сумма чека цели. |
| description | varchar | Описание цели (до 200 символов). |

## Таблица платежей (payments)

Таблица `payments` хранит информацию о платежах, связанных с целями.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор платежа. |
| user\_id | bigint | Идентификатор пользователя, совершившего платеж. |
| name | varchar | Название платежа (до 100 символов). |
| city\_id | integer | Идентификатор города, в котором совершен платеж. |
| count | integer | Сумма платежа. |
| target\_payment\_id | uuid | Уникальный идентификатор цели, связанной с платежом. |

## Таблица заметок (notes)

Таблица `notes` хранит информацию о заметках, связанных с приключениями.

| Название столбца | Тип данных | Описание |
| --- | --- | --- |
| id | integer | Уникальный идентификатор заметки. |
| tg\_id | bigint | Идентификатор пользователя Telegram, создавшего заметку. |
| adventure\_id | integer | Идентификатор приключения, к которому относится заметка. |
| name | varchar | Название заметки (до 100 символов). |
| note\_url | varchar | URL-адрес заметки (до 200 символов). |
| type | enumeration | Тип заметки (изображение, видео, текст и т. д.). |
| status | enumeration | Статус заметки (активна, удалена и т. д.). |

Для работы с базой данных в коде используются следующие объекты:

```kotlin
object UserTable: IntIdTable("users") {
    val name = varchar("name", 50)
    val tgLogin = varchar("tg_login", 50)
    val tgId = long("tg_id")
}

object TargetTable : IntIdTable("target") {
    val name = varchar("name", 100)
    val cityId = integer("city_id")
    val createdAt = long("created_at")
    val date = long("date")
    val time = varchar("time", 20)
    val receipt = integer("receipt")
    val description = varchar("description", 200)
}

object PaymentsTable : IntIdTable("payments") {
    val userId = long("user_id")
    val name = varchar("name", 100)
    val cityId = integer("cityId")
    val count = integer("count")
    val targetPaymentId = uuid("target_payment_id")
}

object NoteTable : IntIdTable("notes") {
    val tgId = long("tg_id")
    val adventureId = integer("adventure_id")
    val name = varchar("name", 100)
    val noteUrl = varchar("note_url", 200)
    val type = enumerationByName("type", 20, NoteMediaType::class)
    val status = enumerationByName("status", 20, NoteStatus::class)
}

object ExtendedUserTable : Table("extended_user") {
    val telegramId = long("tg_id")
    val userOld = integer("user_old")
    val countryCity = varchar("country_city", 100)
    val bio = varchar("bio", 300)

    override val primaryKey = PrimaryKey(telegramId)
}

object AdventureTable : IntIdTable("adventures") {
    val createdAt = long("created_at")
    val name = varchar("name", 100)
    val description = varchar("description", 400)
    val createdBy = long("created_by")
}

object AdventureInvitesTable : Table("adventure_invites") {
    val adventureId = integer("adventure_id")
    val invitedUser = long("invited_user")
}

object AdventureCityTable : IntIdTable("adventure_cities") {
    val name = varchar("name", 100)
    val startTime = long("start_time")
    val endTime = long("end_time")
    val adventureId = integer("adventure_id")
}
```
